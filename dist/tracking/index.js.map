{"version":3,"sources":["../../src/tracking/mixins-map.tracking.ts","../../src/tracking/get-mixins-for-class.tracking.ts","../../src/tracking/has-mixin.tracking.ts","../../src/tracking/register-mixins.tracking.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAMO,IAAM,MAAA,uBAAa,OAAyB,EAAA;;;ACO5C,IAAM,iBAAoB,GAAA,CAAC,KAAyC,KAAA,MAAA,CAAO,IAAI,KAAK;;;ACU9E,IAAA,QAAA,GAAW,CACtB,QAAA,EACA,KACkB,KAAA;AAClB,EAAI,IAAA,CAAC,UAAiB,OAAA,KAAA;AAGtB,EAAI,IAAA,QAAA,YAAoB,OAAc,OAAA,IAAA;AAEtC,EAAA,MAAM,cAAc,QAAU,IAAA,IAAA,GAAA,MAAA,GAAA,QAAA,CAAA,WAAA;AAE9B,EAAI,IAAA,CAAC,aAAoB,OAAA,KAAA;AAGzB,EAAM,MAAA,OAAA,uBAAc,GAAc,EAAA;AAClC,EAAI,IAAA,QAAA,uBAAe,GAAc,EAAA;AACjC,EAAA,QAAA,CAAS,IAAI,WAAW,CAAA;AAExB,EAAO,OAAA,QAAA,CAAS,OAAO,CAAG,EAAA;AAExB,IAAA,IAAI,QAAS,CAAA,GAAA,CAAI,KAAK,CAAA,EAAU,OAAA,IAAA;AAGhC,IAAA,QAAA,CAAS,QAAQ,CAAC,IAAA,KAAS,OAAQ,CAAA,GAAA,CAAI,IAAI,CAAC,CAAA;AAG5C,IAAM,MAAA,WAAA,uBAAkB,GAAc,EAAA;AACtC,IAAS,QAAA,CAAA,OAAA,CAAQ,CAAC,IAAS,KAAA;AAlD/B,MAAA,IAAA,EAAA,EAAA,EAAA;AAoDM,MAAA,MAAM,aAAgB,GAAA,MAAA,CAAO,cAAe,CAAA,IAAA,CAAK,SAAS,CAAA;AAC1D,MAAA,MAAM,qBACF,EAAa,GAAA,CAAA,EAAA,GAAA,IAAA,CAAA,MAAA,KAAb,YACF,MAAO,CAAA,GAAA,CAAI,IAAI,CADb,KAAA,IAAA,GAAA,EAAA,GAED,iBAAiB,aAAc,CAAA,WAAA,IAAe,cAAc,WAAgB,KAAA,MAAA,IACzE,CAAC,aAAc,CAAA,WAAW,IAC1B,EAAC;AAGP,MAAA,IAAI,gBAAkB,EAAA;AACpB,QAAiB,gBAAA,CAAA,OAAA,CAAQ,CAAC,WAA0B,KAAA;AAClD,UAAI,IAAA,WAAA,IAAe,CAAC,OAAA,CAAQ,GAAI,CAAA,WAAW,KAAK,CAAC,QAAA,CAAS,GAAI,CAAA,WAAW,CAAG,EAAA;AAC1E,YAAA,WAAA,CAAY,IAAI,WAAW,CAAA;AAAA;AAC7B,SACD,CAAA;AAAA;AACH,KACD,CAAA;AAGD,IAAW,QAAA,GAAA,WAAA;AAAA;AAIb,EAAO,OAAA,KAAA;AACT;;;AC/Da,IAAA,cAAA,GAAiB,CAAC,UAAA,EAAiB,YAAmC,KAAA;AACjF,EAAO,MAAA,CAAA,GAAA,CAAI,YAAY,YAAY,CAAA;AACrC","file":"index.js","sourcesContent":["/**\n * Keeps track of constituent classes for every mixin class created by ts-mixer.\n * Uses a WeakMap to avoid memory leaks.\n *\n * @internal\n */\nexport const mixins = new WeakMap<any, Function[]>()\n","import type { Class } from '../types/class.type'\nimport { mixins } from './mixins-map.tracking'\n\n/**\n * Gets the constituent classes for a mixin class.\n *\n * @param clazz - The mixin class to get constituents for\n * @returns An array of constituent classes, or undefined if not a mixin\n *\n * @example\n * const AB = Mixin(A, B);\n * const mixins = getMixinsForClass(AB); // [A, B]\n */\nexport const getMixinsForClass = (clazz: Class): Function[] | undefined => mixins.get(clazz)\n","import { mixins } from './mixins-map.tracking'\n\n/**\n * Checks if an instance has a mixin in its prototype chain.\n *\n * This function checks if an instance is an instance of a mixin class or has a mixin class\n * in its prototype chain. It also checks for mixins of mixins.\n *\n * @template M - Type of the mixin\n * @param instance - The instance to check\n * @param mixin - The mixin class to check for\n * @returns True if the instance has the mixin, false otherwise\n *\n * @example\n * ```typescript\n * const AB = Mixin(A, B);\n * const instance = new AB();\n *\n * if (hasMixin(instance, A)) {\n *   // instance has A\n * }\n * ```\n */\nexport const hasMixin = <M>(\n  instance: any,\n  mixin: abstract new (...args: any[]) => M,\n): instance is M => {\n  if (!instance) return false\n\n  // Direct instanceof check\n  if (instance instanceof mixin) return true\n\n  const constructor = instance?.constructor\n\n  if (!constructor) return false\n\n  // Track visited constructors to avoid infinite loops\n  const visited = new Set<Function>()\n  let frontier = new Set<Function>()\n  frontier.add(constructor)\n\n  while (frontier.size > 0) {\n    // Check if the frontier has the mixin we're looking for\n    if (frontier.has(mixin)) return true\n\n    // Mark all frontier items as visited\n    frontier.forEach((item) => visited.add(item))\n\n    // Build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n    const newFrontier = new Set<Function>()\n    frontier.forEach((item) => {\n      // Get mixins for this constructor or use its parent constructor if it's not Object\n      const itemPrototype = Object.getPrototypeOf(item.prototype)\n      const itemConstituents =\n        ((item as any).mixins ??\n        mixins.get(item) ??\n        (itemPrototype && itemPrototype.constructor && itemPrototype.constructor !== Object))\n          ? [itemPrototype.constructor]\n          : []\n\n      // Add unvisited constituents to the new frontier\n      if (itemConstituents) {\n        itemConstituents.forEach((constituent: Function) => {\n          if (constituent && !visited.has(constituent) && !frontier.has(constituent)) {\n            newFrontier.add(constituent)\n          }\n        })\n      }\n    })\n\n    // We have a new frontier, now search again\n    frontier = newFrontier\n  }\n\n  // If we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n  return false\n}\n","import { mixins } from './mixins-map.tracking'\n\n/**\n * Registers constituent classes for a mixin class.\n *\n * This function is used internally by the Mixin function to register the constituent classes\n * for a mixin class. This information is used by the hasMixin and getMixinsForClass functions.\n *\n * @param mixedClass - The mixin class\n * @param constituents - The constituent classes\n *\n * @internal\n */\nexport const registerMixins = (mixedClass: any, constituents: Function[]): void => {\n  mixins.set(mixedClass, constituents)\n}\n"]}