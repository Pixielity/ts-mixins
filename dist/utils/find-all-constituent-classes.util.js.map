{"version":3,"sources":["../../src/utils/proto-chain.util.ts","../../src/tracking/mixins-map.tracking.ts","../../src/tracking/get-mixins-for-class.tracking.ts","../../src/utils/find-all-constituent-classes.util.ts"],"names":[],"mappings":";;;AAYO,IAAM,aAAa,CAAC,GAAA,EAAa,YAAyB,GAAA,CAAC,GAAG,CAAgB,KAAA;AAEnF,EAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,cAAA,CAAe,GAAG,CAAA;AAGvC,EAAI,IAAA,KAAA,KAAU,MAAa,OAAA,YAAA;AAG3B,EAAA,OAAO,WAAW,KAAO,EAAA,CAAC,GAAG,YAAA,EAAc,KAAK,CAAC,CAAA;AACnD,CAAA;;;ACfO,IAAM,MAAA,uBAAa,OAAyB,EAAA;;;ACO5C,IAAM,iBAAoB,GAAA,CAAC,KAAyC,KAAA,MAAA,CAAO,IAAI,KAAK,CAAA;;;ACE9E,IAAA,yBAAA,GAA4B,IAAI,OAA8B,KAAA;AAf3E,EAAA,IAAA,EAAA;AAiBE,EAAM,MAAA,UAAA,uBAAiB,GAAW,EAAA;AAClC,EAAA,MAAM,2BAAe,IAAA,GAAA,CAAW,CAAC,GAAG,OAAO,CAAC,CAAA;AAG5C,EAAO,OAAA,QAAA,CAAS,OAAO,CAAG,EAAA;AACxB,IAAA,KAAA,MAAW,SAAS,QAAU,EAAA;AAE5B,MAAM,MAAA,iBAAA,GAAoB,WAAW,KAAM,CAAA,SAAS,EAAE,GAAI,CAAA,CAAC,KAAU,KAAA,KAAA,CAAM,WAAW,CAAA;AAGtF,MAAA,MAAM,YAAe,GAAA,CAAA,EAAA,GAAA,iBAAA,CAAkB,KAAK,CAAA,KAAvB,YAA4B,EAAC;AAGlD,MAAA,MAAM,qBAAwB,GAAA,CAAC,GAAG,iBAAA,EAAmB,GAAG,YAAY,CAAA;AAGpE,MAAM,MAAA,UAAA,GAAa,sBAAsB,MAAO,CAAA,CAAC,MAAM,CAAC,UAAA,CAAW,GAAI,CAAA,CAAC,CAAC,CAAA;AAGzE,MAAA,KAAA,MAAW,QAAY,IAAA,UAAA,EAAqB,QAAA,CAAA,GAAA,CAAI,QAAQ,CAAA;AAGxD,MAAA,UAAA,CAAW,IAAI,KAAK,CAAA;AAGpB,MAAA,QAAA,CAAS,OAAO,KAAK,CAAA;AAAA;AACvB;AAGF,EAAO,OAAA,CAAC,GAAG,UAAU,CAAA;AACvB","file":"find-all-constituent-classes.util.js","sourcesContent":["/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.\n *\n * The order of prototypes will be closest to farthest in the chain.\n * This function is used internally by various functions to traverse the prototype chain.\n *\n * @param obj - The object to get the prototype chain for\n * @param currentChain - The current chain (used for recursion)\n * @returns An array of objects representing the prototype chain\n *\n * @internal\n */\nexport const protoChain = (obj: object, currentChain: object[] = [obj]): object[] => {\n  // Get the prototype of the object\n  const proto = Object.getPrototypeOf(obj)\n\n  // If we've reached the end of the chain, return the current chain\n  if (proto === null) return currentChain\n\n  // Recursively get the rest of the chain\n  return protoChain(proto, [...currentChain, proto])\n}\n","/**\n * Keeps track of constituent classes for every mixin class created by ts-mixer.\n * Uses a WeakMap to avoid memory leaks.\n *\n * @internal\n */\nexport const mixins = new WeakMap<any, Function[]>()\n","import type { Class } from '../types/class.type'\nimport { mixins } from './mixins-map.tracking'\n\n/**\n * Gets the constituent classes for a mixin class.\n *\n * @param clazz - The mixin class to get constituents for\n * @returns An array of constituent classes, or undefined if not a mixin\n *\n * @example\n * const AB = Mixin(A, B);\n * const mixins = getMixinsForClass(AB); // [A, B]\n */\nexport const getMixinsForClass = (clazz: Class): Function[] | undefined => mixins.get(clazz)\n","import type { Class } from '../types/class.type'\nimport { protoChain } from '../utils/proto-chain.util'\nimport { getMixinsForClass } from '../tracking/get-mixins-for-class.tracking'\n\n/**\n * Finds all constituent classes for a set of classes, including those in the prototype chain and mixins.\n *\n * This function is used internally by the deepDecoratorSearch function to find all classes\n * that might have decorators to inherit.\n *\n * @param classes - Classes to find constituents for\n * @returns Array of all constituent classes\n *\n * @internal\n */\nexport const findAllConstituentClasses = (...classes: Class[]): Class[] => {\n  // Use sets to avoid duplicates\n  const allClasses = new Set<Class>()\n  const frontier = new Set<Class>([...classes])\n\n  // Breadth-first search to find all constituent classes\n  while (frontier.size > 0) {\n    for (const clazz of frontier) {\n      // Get classes from the prototype chain\n      const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor)\n\n      // Get classes from mixins\n      const mixinClasses = getMixinsForClass(clazz) ?? []\n\n      // Combine all potential new classes\n      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses] as Class[]\n\n      // Filter out classes we've already seen\n      const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c))\n\n      // Add new classes to the frontier\n      for (const newClass of newClasses) frontier.add(newClass)\n\n      // Add the current class to the set of all classes\n      allClasses.add(clazz)\n\n      // Remove the current class from the frontier\n      frontier.delete(clazz)\n    }\n  }\n\n  return [...allClasses]\n}\n"]}