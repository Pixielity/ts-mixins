{"version":3,"sources":["../../src/utils/proto-chain.util.ts","../../src/utils/nearest-common-proto.util.ts"],"names":["protoChain"],"mappings":";;;;;;;;;;;AAYO,IAAM,aAAa,CAAC,GAAA,EAAa,YAAyB,GAAA,CAAC,GAAG,CAAgB,KAAA;AAEnF,EAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,cAAA,CAAe,GAAG,CAAA;AAGvC,EAAI,IAAA,KAAA,KAAU,MAAa,OAAA,YAAA;AAG3B,EAAA,OAAO,WAAW,KAAO,EAAA,CAAC,GAAG,YAAA,EAAc,KAAK,CAAC,CAAA;AACnD,CAAA;;;ACPa,IAAA,kBAAA,GAAqB,IAAI,IAAuC,KAAA;AAE3E,EAAI,IAAA,IAAA,CAAK,MAAW,KAAA,CAAA,EAAU,OAAA,MAAA;AAE9B,EAAA,IAAI,WAAkC,GAAA,MAAA;AAGtC,EAAA,MAAM,cAAc,IAAK,CAAA,GAAA,CAAI,CAAC,GAAQ,KAAA,UAAA,CAAW,GAAG,CAAC,CAAA;AAGrD,EAAA,OAAO,YAAY,KAAM,CAAA,CAACA,gBAAeA,WAAW,CAAA,MAAA,GAAS,CAAC,CAAG,EAAA;AAE/D,IAAA,MAAM,SAAS,WAAY,CAAA,GAAA,CAAI,CAACA,WAAeA,KAAAA,WAAAA,CAAW,KAAK,CAAA;AAC/D,IAAM,MAAA,oBAAA,GAAuB,OAAO,CAAC,CAAA;AAGrC,IAAA,IAAI,OAAO,KAAM,CAAA,CAAC,UAAU,KAAU,KAAA,oBAAoB,GAAiB,WAAA,GAAA,oBAAA;AAAA,SACtE;AAAA;AAGP,EAAO,OAAA,WAAA;AACT","file":"nearest-common-proto.util.mjs","sourcesContent":["/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.\n *\n * The order of prototypes will be closest to farthest in the chain.\n * This function is used internally by various functions to traverse the prototype chain.\n *\n * @param obj - The object to get the prototype chain for\n * @param currentChain - The current chain (used for recursion)\n * @returns An array of objects representing the prototype chain\n *\n * @internal\n */\nexport const protoChain = (obj: object, currentChain: object[] = [obj]): object[] => {\n  // Get the prototype of the object\n  const proto = Object.getPrototypeOf(obj)\n\n  // If we've reached the end of the chain, return the current chain\n  if (proto === null) return currentChain\n\n  // Recursively get the rest of the chain\n  return protoChain(proto, [...currentChain, proto])\n}\n","import { protoChain } from './proto-chain.util'\n\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.\n *\n * For most unrelated objects, this function should return Object.prototype.\n * This function is used internally by the hardMixProtos function to find the common ancestor\n * of all ingredients.\n *\n * @param objs - The objects to find the common ancestor for\n * @returns The nearest common ancestor, or undefined if no objects were provided\n *\n * @internal\n */\nexport const nearestCommonProto = (...objs: object[]): object | undefined => {\n  // If no objects provided, return undefined\n  if (objs.length === 0) return undefined\n\n  let commonProto: object | undefined = undefined\n\n  // Get the prototype chain for each object\n  const protoChains = objs.map((obj) => protoChain(obj))\n\n  // Find the nearest common ancestor by working backwards from Object.prototype\n  while (protoChains.every((protoChain) => protoChain.length > 0)) {\n    // Get the last prototype in each chain (closest to Object.prototype)\n    const protos = protoChains.map((protoChain) => protoChain.pop())\n    const potentialCommonProto = protos[0]\n\n    // If all prototypes are the same, we've found a common ancestor\n    if (protos.every((proto) => proto === potentialCommonProto)) commonProto = potentialCommonProto\n    else break\n  }\n\n  return commonProto\n}\n"]}