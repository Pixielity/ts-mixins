{"version":3,"sources":["../../src/utils/apply-prop-and-method-decorators.util.ts"],"names":[],"mappings":";AAcO,IAAM,+BAA+B,CAC1C,uBAAA,EACA,MACA,EAAA,eAAA,GAA4B,EACnB,KAAA;AACT,EAAA,MAAM,iBAAiB,uBAAwB,CAAA,QAAA;AAC/C,EAAA,MAAM,mBAAmB,uBAAwB,CAAA,MAAA;AAGjD,EAAA,IAAI,cAAgB,EAAA;AAClB,IAAA,KAAA,MAAW,OAAO,cAAgB,EAAA;AAChC,MAAW,KAAA,MAAA,SAAA,IAAa,cAAe,CAAA,GAAG,CAAG,EAAA;AAC3C,QAAA,SAAA,CAAU,QAAQ,GAAG,CAAA;AAAA;AACvB;AACF;AAIF,EAAA,IAAI,gBAAkB,EAAA;AACpB,IAAA,KAAA,MAAW,OAAO,gBAAkB,EAAA;AAElC,MAAA,MAAM,UAAa,GAAA,MAAA,CAAO,wBAAyB,CAAA,MAAA,EAAQ,GAAG,CAAA;AAE9D,MAAA,IAAI,UAAY,EAAA;AAEd,QAAW,KAAA,MAAA,SAAA,IAAa,gBAAiB,CAAA,GAAG,CAAG,EAAA;AAE7C,UAAA,MAAM,MAAS,GAAA,SAAA,CAAU,MAAQ,EAAA,GAAA,EAAK,UAAU,CAAA;AAEhD,UAAA,IAAI,MAAQ,EAAA;AACV,YAAO,MAAA,CAAA,cAAA,CAAe,MAAQ,EAAA,GAAA,EAAK,MAAM,CAAA;AAAA;AAC3C;AACF;AAKF,MAAI,IAAA,MAAA,CAAO,gBAAgB,QAAU,EAAA;AAGnC,QAAA,KAAA,MAAW,kBAAkB,eAAiB,EAAA;AAC5C,UAAA,MAAM,kBAAqB,GAAA,MAAA,CAAO,wBAAyB,CAAA,cAAA,EAAgB,GAAG,CAAA;AAC9E,UAAA,IAAI,kBAAoB,EAAA;AACtB,YAAW,KAAA,MAAA,SAAA,IAAa,gBAAiB,CAAA,GAAG,CAAG,EAAA;AAC7C,cAAU,SAAA,CAAA,cAAA,EAAgB,KAAK,kBAAkB,CAAA;AAAA;AACnD;AACF;AACF;AACF;AACF;AAEJ","file":"apply-prop-and-method-decorators.util.mjs","sourcesContent":["import type { PropertyAndMethodDecorators } from \"../interfaces/property-and-method-decorators.interface\"\n\n/**\n * Applies property and method decorators to a target object.\n *\n * This function is used internally by the Mixin function to apply property and method decorators\n * to the mixed class and its prototype.\n *\n * @param propAndMethodDecorators - Property and method decorators to apply\n * @param target - Target object to apply decorators to\n * @param originalTargets - Original objects that had these decorators (for proper context)\n *\n * @internal\n */\nexport const applyPropAndMethodDecorators = (\n  propAndMethodDecorators: PropertyAndMethodDecorators,\n  target: Object,\n  originalTargets: Object[] = [],\n): void => {\n  const propDecorators = propAndMethodDecorators.property\n  const methodDecorators = propAndMethodDecorators.method\n\n  // Apply property decorators\n  if (propDecorators) {\n    for (const key in propDecorators) {\n      for (const decorator of propDecorators[key]) {\n        decorator(target, key)\n      }\n    }\n  }\n\n  // Apply method decorators\n  if (methodDecorators) {\n    for (const key in methodDecorators) {\n      // Get the descriptor from the target\n      const descriptor = Object.getOwnPropertyDescriptor(target, key)\n\n      if (descriptor) {\n        // Apply each decorator to the target (mixed class)\n        for (const decorator of methodDecorators[key]) {\n          // Apply the decorator and update the property descriptor if needed\n          const result = decorator(target, key, descriptor)\n\n          if (result) {\n            Object.defineProperty(target, key, result)\n          }\n        }\n      }\n\n      // For static method decorators, we need to ensure they're called with both\n      // the original class and the mixed class\n      if (target.constructor === Function) { // This is a static context\n        // We've already applied the decorators to the target (mixed class) above\n        // Now we need to apply them to the original classes as well\n        for (const originalTarget of originalTargets) {\n          const originalDescriptor = Object.getOwnPropertyDescriptor(originalTarget, key)\n          if (originalDescriptor) {\n            for (const decorator of methodDecorators[key]) {\n              decorator(originalTarget, key, originalDescriptor)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n"]}