{"version":3,"sources":["../../src/utils/decorators-map.util.ts","../../src/utils/get-decorators-for-class.util.ts","../../src/utils/decorate-class.util.ts","../../src/utils/decorate-member.util.ts","../../src/decorators/decorate.decorator.ts"],"names":[],"mappings":";;;AAUO,IAAM,UAAA,uBAAyC,GAAI,EAAA;;;ACGnD,IAAM,qBAAA,GAAwB,CAAC,KAAiB,KAAA;AAErD,EAAI,IAAA,kBAAA,GAAqB,UAAW,CAAA,GAAA,CAAI,KAAK,CAAA;AAG7C,EAAA,IAAI,CAAC,kBAAoB,EAAA;AACvB,IAAA,kBAAA,GAAqB,EAAC;AACtB,IAAW,UAAA,CAAA,GAAA,CAAI,OAAO,kBAAkB,CAAA;AAAA;AAG1C,EAAO,OAAA,kBAAA;AACT,CAAA;;;ACTO,IAAM,aAAgB,GAAA,CAA2B,SACrD,KAAA,CAAC,KAAiB,KAAA;AAEjB,EAAM,MAAA,kBAAA,GAAqB,sBAAsB,KAAK,CAAA;AAGtD,EAAA,IAAI,kBAAkB,kBAAmB,CAAA,KAAA;AACzC,EAAA,IAAI,CAAC,eAAiB,EAAA;AACpB,IAAA,eAAA,GAAkB,EAAC;AACnB,IAAA,kBAAA,CAAmB,KAAQ,GAAA,eAAA;AAAA;AAI7B,EAAA,eAAA,CAAgB,KAAK,SAAS,CAAA;AAG9B,EAAA,OAAO,UAAU,KAAK,CAAA;AACxB,CAAA;;;ACjBK,IAAM,iBAAiB,CAAgD,SAAA,KAC3E,CAAC,MAAA,EAAgB,KAAsB,UAAoC,KAAA;AAhB9E,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA;AAkBI,EAAA,MAAM,mBAAsB,GAAA,OAAO,MAAW,KAAA,UAAA,GAAa,QAAW,GAAA,UAAA;AAItE,EAAA,MAAM,gBAAgB,OAAQ,MAAA,CAAe,GAAG,CAAA,KAAM,aAAa,QAAW,GAAA,UAAA;AAI9E,EAAA,MAAM,KACJ,GAAA,mBAAA,KAAwB,QACnB,GAAA,MAAA,GACA,MAAO,CAAA,WAAA;AAGd,EAAM,MAAA,kBAAA,GAAqB,sBAAsB,KAAK,CAAA;AAGtD,EAAA,MAAM,uBAA0B,GAAA,CAAA,EAAA,GAAA,kBAAA,IAAA,IAAA,GAAA,MAAA,GAAA,kBAAA,CAAqB,mBAArB,CAAA,KAAA,IAAA,GAAA,EAAA,GAA6C,EAAC;AAC9E,EAAA,kBAAA,CAAmB,mBAAmB,CAAI,GAAA,uBAAA;AAG1C,EAAA,MAAM,iBAAoB,GAAA,CAAA,EAAA,GAAA,uBAAA,IAAA,IAAA,GAAA,MAAA,GAAA,uBAAA,CAA0B,aAA1B,CAAA,KAAA,IAAA,GAAA,EAAA,GAA4C,EAAC;AACvE,EAAA,uBAAA,CAAwB,aAAa,CAAI,GAAA,iBAAA;AAGzC,EAAA,MAAM,SAAS,OAAO,GAAA,KAAQ,QAAW,GAAA,GAAA,CAAI,UAAa,GAAA,GAAA;AAG1D,EAAA,MAAM,gBAAmB,GAAA,CAAA,EAAA,GAAA,iBAAA,IAAA,IAAA,GAAA,MAAA,GAAA,iBAAA,CAAoB,MAApB,CAAA,KAAA,IAAA,GAAA,EAAA,GAA+B,EAAC;AACzD,EAAA,iBAAA,CAAkB,MAAM,CAAI,GAAA,gBAAA;AAG5B,EAAA,gBAAA,CAAiB,KAAK,SAAgB,CAAA;AAItC,EAAA,IAAI,eAAe,MAAW,EAAA;AAE5B,IAAQ,OAAA,SAAA,CAA8B,MAAQ,EAAA,GAAA,EAAK,UAAU,CAAA;AAAA,GACxD,MAAA;AAEL,IAAQ,OAAA,SAAA,CAAgC,QAAQ,GAAG,CAAA;AAAA;AAEvD,CAAA;;;ACnCK,IAAM,QAAW,GAAA,CACtB,SAEC,KAAA,CAAA,GAAI,IAAgB,KAAA;AAEnB,EAAI,IAAA,IAAA,CAAK,WAAW,CAAG,EAAA,OAAO,cAAc,SAA2B,CAAA,CAAE,IAAK,CAAA,CAAC,CAAC,CAAA;AAGhF,EAAA,OAAO,eAAe,SAAgD,CAAA;AAAA,IACpE,GAAI;AAAA,GACN;AACF","file":"decorate.decorator.js","sourcesContent":["import type { Class } from '../types/class.type'\nimport type { Decorators } from '../interfaces/decorators.interface'\n\n/**\n * Map to store decorators for classes.\n *\n * This map is used internally by the Decorate function to track decorators for inheritance in mixed classes.\n *\n * @internal\n */\nexport const decorators: Map<Class, Decorators> = new Map()\n","import type { Class } from '../types/class.type'\nimport { decorators } from './decorators-map.util'\n\n/**\n * Gets or creates a decorator object for a class.\n *\n * This function is used internally by the Decorate function to track decorators for inheritance in mixed classes.\n *\n * @param clazz - Class to get decorators for\n * @returns Decorator object for the class\n *\n * @internal\n */\nexport const getDecoratorsForClass = (clazz: Class) => {\n  // Get existing decorators for the class\n  let decoratorsForClass = decorators.get(clazz)\n\n  // If no decorators exist, create a new object\n  if (!decoratorsForClass) {\n    decoratorsForClass = {}\n    decorators.set(clazz, decoratorsForClass)\n  }\n\n  return decoratorsForClass\n}\n","import type { Class } from '../types/class.type'\nimport { getDecoratorsForClass } from './get-decorators-for-class.util'\n\n/**\n * Decorates a class with a class decorator.\n *\n * This function is used internally by the Decorate function to track class decorators\n * for inheritance in mixed classes.\n *\n * @template T - Type of class decorator\n * @param decorator - Class decorator to apply\n * @returns Decorated class decorator\n *\n * @internal\n */\nexport const decorateClass = <T extends ClassDecorator>(decorator: T): T =>\n  ((clazz: Class) => {\n    // Get or create decorators for the class\n    const decoratorsForClass = getDecoratorsForClass(clazz)\n\n    // Get or create class decorators array\n    let classDecorators = decoratorsForClass.class\n    if (!classDecorators) {\n      classDecorators = []\n      decoratorsForClass.class = classDecorators\n    }\n\n    // Add the decorator to the class decorators array\n    classDecorators.push(decorator)\n\n    // Apply the decorator to the class\n    return decorator(clazz)\n  }) as T\n","import type { Class } from '../types/class.type'\nimport { getDecoratorsForClass } from './get-decorators-for-class.util'\n\n/**\n * Decorates a class member with a property or method decorator.\n *\n * This function is used internally by the Decorate function to track property and method decorators\n * for inheritance in mixed classes.\n *\n * @template T - Type of decorator (PropertyDecorator or MethodDecorator)\n * @param decorator - Property or method decorator to apply\n * @returns Decorated property or method decorator\n *\n * @internal\n */\nexport const decorateMember = <T extends PropertyDecorator | MethodDecorator>(decorator: T): T =>\n  ((object: Object, key: string | symbol, descriptor?: PropertyDescriptor) => {\n    // Determine if the decorator is for a static or instance member\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance'\n\n    // Determine if the decorator is for a method or property\n    // Use type assertion to allow indexing with string | symbol\n    const decoratorType = typeof (object as any)[key] === 'function' ? 'method' : 'property'\n\n    // Get the class being decorated\n    // Use type assertion to ensure correct type\n    const clazz: Class =\n      decoratorTargetType === 'static'\n        ? (object as unknown as Class)\n        : (object.constructor as Class)\n\n    // Get or create decorators for the class\n    const decoratorsForClass = getDecoratorsForClass(clazz)\n\n    // Get or create decorators for the target type (static or instance)\n    const decoratorsForTargetType = decoratorsForClass?.[decoratorTargetType] ?? {}\n    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType\n\n    // Get or create decorators for the type (method or property)\n    const decoratorsForType = decoratorsForTargetType?.[decoratorType] ?? {}\n    decoratorsForTargetType[decoratorType] = decoratorsForType as any\n\n    // Convert symbol keys to string representation for storage\n    const keyStr = typeof key === 'symbol' ? key.toString() : key\n\n    // Get or create decorators for the key\n    const decoratorsForKey = decoratorsForType?.[keyStr] ?? []\n    decoratorsForType[keyStr] = decoratorsForKey\n\n    // Add the decorator to the decorators for the key\n    decoratorsForKey.push(decorator as any)\n\n    // Apply the decorator to the member\n    // Handle both PropertyDecorator and MethodDecorator cases\n    if (descriptor !== undefined) {\n      // It's a MethodDecorator\n      return (decorator as MethodDecorator)(object, key, descriptor)\n    } else {\n      // It's a PropertyDecorator\n      return (decorator as PropertyDecorator)(object, key)\n    }\n  }) as T\n","import { decorateClass } from '../utils/decorate-class.util'\nimport { decorateMember } from '../utils/decorate-member.util'\n\n/**\n * Decorator factory that tracks decorators for use with mixins.\n *\n * This function wraps a decorator and tracks it for inheritance in mixed classes.\n * It handles class decorators, property decorators, and method decorators.\n *\n * @template T - Type of decorator (ClassDecorator, PropertyDecorator, or MethodDecorator)\n * @param decorator - Decorator to track\n * @returns Tracked decorator that will be inherited by mixed classes\n *\n * @example\n * // Track a class decorator\n * @Decorate(MyClassDecorator)\n * class MyClass {\n *   // Track a property decorator\n *   @Decorate(MyPropertyDecorator)\n *   myProperty: string;\n *\n *   // Track a method decorator\n *   @Decorate(MyMethodDecorator)\n *   myMethod() {}\n * }\n */\nexport const Decorate = <T extends ClassDecorator | PropertyDecorator | MethodDecorator>(\n  decorator: T,\n): T =>\n  ((...args: any[]) => {\n    // If only one argument, it's a class decorator\n    if (args.length === 1) return decorateClass(decorator as ClassDecorator)(args[0])\n\n    // Otherwise, it's a property or method decorator\n    return decorateMember(decorator as PropertyDecorator | MethodDecorator)(\n      ...(args as [Object, string, TypedPropertyDescriptor<any>]),\n    )\n  }) as T\n"]}