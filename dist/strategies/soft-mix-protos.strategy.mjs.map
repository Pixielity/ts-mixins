{"version":3,"sources":["../../src/utils/proto-chain.util.ts","../../src/strategies/get-ingredient-with-prop.strategy.ts","../../src/strategies/proxy-mix.strategy.ts","../../src/strategies/soft-mix-protos.strategy.ts"],"names":[],"mappings":"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","file":"soft-mix-protos.strategy.mjs","sourcesContent":["/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.\n *\n * The order of prototypes will be closest to farthest in the chain.\n * This function is used internally by various functions to traverse the prototype chain.\n *\n * @param obj - The object to get the prototype chain for\n * @param currentChain - The current chain (used for recursion)\n * @returns An array of objects representing the prototype chain\n *\n * @internal\n */\nexport const protoChain = (obj: object, currentChain: object[] = [obj]): object[] => {\n  // Get the prototype of the object\n  const proto = Object.getPrototypeOf(obj)\n\n  // If we've reached the end of the chain, return the current chain\n  if (proto === null) return currentChain\n\n  // Recursively get the rest of the chain\n  return protoChain(proto, [...currentChain, proto])\n}\n","import { protoChain } from '../utils/proto-chain.util'\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n *\n * This function is used by the proxy mixing strategy to find the ingredient that has a specific property.\n * It searches through the prototype chains of all ingredients in a breadth-first manner.\n *\n * @param prop - Property to search for\n * @param ingredients - Ingredients to search in\n * @returns The ingredient with the property, or undefined if not found\n *\n * @internal\n */\nexport const getIngredientWithProp = (prop: string | number | symbol, ingredients: any[]): any => {\n  // Get the prototype chain for each ingredient\n  const protoChains = ingredients.map((ingredient) => protoChain(ingredient))\n\n  // Since we search breadth-first, we need to keep track of our depth in the prototype chains\n  let protoDepth = 0\n\n  // Not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n  // prototype chains has an object at this depth\n  let protosAreLeftToSearch = true\n\n  while (protosAreLeftToSearch) {\n    // With the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n    protosAreLeftToSearch = false\n\n    // Scan through the ingredients right to left (to prioritize later ingredients)\n    for (let i = ingredients.length - 1; i >= 0; i--) {\n      const searchTarget = protoChains[i][protoDepth]\n      if (searchTarget !== undefined && searchTarget !== null) {\n        // If we find something, this is proof that this horizontal slice potentially has more objects to search\n        protosAreLeftToSearch = true\n\n        // Eureka, we found it\n        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n          return protoChains[i][0]\n        }\n      }\n    }\n\n    // Move to the next level in the prototype chain\n    protoDepth++\n  }\n\n  // Property not found in any ingredient\n  return undefined\n}\n","import { getIngredientWithProp } from './get-ingredient-with-prop.strategy'\n\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.\n *\n * The optional prototype argument allows the mixed object to sit downstream of an existing prototype chain.\n * Note that \"properties\" cannot be added, deleted, or modified.\n *\n * This strategy is less performant than the hard mix strategy, but it reflects changes to the source objects.\n *\n * @param ingredients - Ingredients to mix\n * @param prototype - Optional prototype for the mixed object\n * @returns A proxy that mixes the ingredients\n *\n * @internal\n */\nexport const proxyMix = (ingredients: any[], prototype = Object.prototype): any =>\n  new Proxy(\n    {},\n    {\n      /**\n       * Returns the prototype of the mixed object.\n       */\n      getPrototypeOf() {\n        return prototype\n      },\n\n      /**\n       * Prevents setting the prototype of the mixed object.\n       */\n      setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer')\n      },\n\n      /**\n       * Returns the property descriptor for a property from the appropriate ingredient.\n       */\n      getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop)\n      },\n\n      /**\n       * Prevents defining new properties on the mixed object.\n       */\n      defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer')\n      },\n\n      /**\n       * Checks if a property exists on any ingredient or the prototype.\n       */\n      has(_, prop) {\n        return (\n          getIngredientWithProp(prop, ingredients) !== undefined ||\n          (prototype as any)[prop] !== undefined\n        )\n      },\n\n      /**\n       * Gets a property from the appropriate ingredient or the prototype.\n       */\n      get(_, prop) {\n        const ingredient = getIngredientWithProp(prop, ingredients)\n        if (ingredient !== undefined) {\n          return ingredient[prop]\n        }\n        // Use a type assertion to tell TypeScript this access is valid\n        return (prototype as any)[prop]\n      },\n\n      /**\n       * Sets a property on the appropriate ingredient.\n       */\n      set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients)\n        if (ingredientWithProp === undefined)\n          throw new Error('Cannot set new properties on Proxies created by ts-mixer')\n\n        ingredientWithProp[prop] = val\n        return true\n      },\n\n      /**\n       * Prevents deleting properties from the mixed object.\n       */\n      deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer')\n      },\n\n      /**\n       * Returns all own property names from all ingredients.\n       */\n      ownKeys() {\n        return ingredients\n          .map(Object.getOwnPropertyNames)\n          .reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)))\n      },\n    },\n  )\n","import { proxyMix } from './proxy-mix.strategy'\n\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.\n *\n * The mixing is achieved by proxying all property access to the ingredients.\n * This is not ES5 compatible and less performant.\n * However, any changes made to the source prototypes will be reflected in the proxy-prototype,\n * which may be desirable.\n *\n * @param ingredients - Prototype ingredients to mix\n * @param constructor - Constructor function for the mixed prototype\n * @returns A proxy-prototype that mixes the ingredients\n *\n * @internal\n */\nexport const softMixProtos = (ingredients: any[], constructor: Function): object =>\n  proxyMix([...ingredients, { constructor }])\n"]}