{"version":3,"sources":["../../src/utils/proto-chain.util.ts","../../src/strategies/get-ingredient-with-prop.strategy.ts","../../src/utils/copy-props.util.ts","../../src/utils/nearest-common-proto.util.ts","../../src/strategies/hard-mix-protos.strategy.ts","../../src/strategies/proxy-mix.strategy.ts","../../src/strategies/soft-mix-protos.strategy.ts"],"names":["protoChain"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.\n *\n * The order of prototypes will be closest to farthest in the chain.\n * This function is used internally by various functions to traverse the prototype chain.\n *\n * @param obj - The object to get the prototype chain for\n * @param currentChain - The current chain (used for recursion)\n * @returns An array of objects representing the prototype chain\n *\n * @internal\n */\nexport const protoChain = (obj: object, currentChain: object[] = [obj]): object[] => {\n  // Get the prototype of the object\n  const proto = Object.getPrototypeOf(obj)\n\n  // If we've reached the end of the chain, return the current chain\n  if (proto === null) return currentChain\n\n  // Recursively get the rest of the chain\n  return protoChain(proto, [...currentChain, proto])\n}\n","import { protoChain } from '../utils/proto-chain.util'\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n *\n * This function is used by the proxy mixing strategy to find the ingredient that has a specific property.\n * It searches through the prototype chains of all ingredients in a breadth-first manner.\n *\n * @param prop - Property to search for\n * @param ingredients - Ingredients to search in\n * @returns The ingredient with the property, or undefined if not found\n *\n * @internal\n */\nexport const getIngredientWithProp = (prop: string | number | symbol, ingredients: any[]): any => {\n  // Get the prototype chain for each ingredient\n  const protoChains = ingredients.map((ingredient) => protoChain(ingredient))\n\n  // Since we search breadth-first, we need to keep track of our depth in the prototype chains\n  let protoDepth = 0\n\n  // Not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n  // prototype chains has an object at this depth\n  let protosAreLeftToSearch = true\n\n  while (protosAreLeftToSearch) {\n    // With the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n    protosAreLeftToSearch = false\n\n    // Scan through the ingredients right to left (to prioritize later ingredients)\n    for (let i = ingredients.length - 1; i >= 0; i--) {\n      const searchTarget = protoChains[i][protoDepth]\n      if (searchTarget !== undefined && searchTarget !== null) {\n        // If we find something, this is proof that this horizontal slice potentially has more objects to search\n        protosAreLeftToSearch = true\n\n        // Eureka, we found it\n        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n          return protoChains[i][0]\n        }\n      }\n    }\n\n    // Move to the next level in the prototype chain\n    protoDepth++\n  }\n\n  // Property not found in any ingredient\n  return undefined\n}\n","/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.\n * Additionally gives the option to exclude properties by name.\n *\n * @param dest - The destination object\n * @param src - The source object\n * @param exclude - Optional array of property names to exclude\n *\n * @internal\n */\nexport const copyProps = (dest: object, src: object, exclude: string[] = []): void => {\n  // Get all property descriptors from the source object\n  const props = Object.getOwnPropertyDescriptors(src)\n\n  // Remove excluded properties\n  for (const prop of exclude) delete props[prop]\n\n  // Define all properties on the destination object\n  Object.defineProperties(dest, props)\n}\n","import { protoChain } from './proto-chain.util'\n\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.\n *\n * For most unrelated objects, this function should return Object.prototype.\n * This function is used internally by the hardMixProtos function to find the common ancestor\n * of all ingredients.\n *\n * @param objs - The objects to find the common ancestor for\n * @returns The nearest common ancestor, or undefined if no objects were provided\n *\n * @internal\n */\nexport const nearestCommonProto = (...objs: object[]): object | undefined => {\n  // If no objects provided, return undefined\n  if (objs.length === 0) return undefined\n\n  let commonProto: object | undefined = undefined\n\n  // Get the prototype chain for each object\n  const protoChains = objs.map((obj) => protoChain(obj))\n\n  // Find the nearest common ancestor by working backwards from Object.prototype\n  while (protoChains.every((protoChain) => protoChain.length > 0)) {\n    // Get the last prototype in each chain (closest to Object.prototype)\n    const protos = protoChains.map((protoChain) => protoChain.pop())\n    const potentialCommonProto = protos[0]\n\n    // If all prototypes are the same, we've found a common ancestor\n    if (protos.every((proto) => proto === potentialCommonProto)) commonProto = potentialCommonProto\n    else break\n  }\n\n  return commonProto\n}\n","import { copyProps, nearestCommonProto, protoChain } from '../utils'\n\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.\n *\n * The mixing is achieved by first identifying the nearest common ancestor and using it as the prototype for a new object.\n * Then all properties/methods downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.\n * However, it's not as flexible as updates to the source prototypes aren't captured by the mixed result.\n *\n * @param ingredients - Prototype ingredients to mix\n * @param constructor - Constructor function for the mixed prototype, or null\n * @param exclude - Optional array of property names to exclude\n * @returns A new prototype object that mixes the ingredients\n *\n * @internal\n */\nexport const hardMixProtos = (\n  ingredients: any[],\n  constructor: Function | null,\n  exclude: string[] = [],\n): object => {\n  // Find the nearest common ancestor of all ingredients, or use Object.prototype if none\n  const base = nearestCommonProto(...ingredients) ?? Object.prototype\n\n  // Create a new object with the common ancestor as its prototype\n  const mixedProto = Object.create(base)\n\n  // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.\n  // We init the list with the proto chain below the nearest common ancestor because we don't want any of those\n  // methods mixed in when they will already be accessible via prototype access.\n  const visitedProtos = protoChain(base)\n\n  // Process each ingredient\n  for (const prototype of ingredients) {\n    // Get the prototype chain for this ingredient\n    const protos = protoChain(prototype)\n\n    // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n    // This ensures that properties closer to the actual class take precedence over properties\n    // from further up the prototype chain.\n    for (let i = protos.length - 1; i >= 0; i--) {\n      const newProto = protos[i]\n\n      // Only copy properties from prototypes we haven't visited yet\n      if (visitedProtos.indexOf(newProto) === -1) {\n        copyProps(mixedProto, newProto, ['constructor', ...exclude])\n        visitedProtos.push(newProto)\n      }\n    }\n  }\n\n  // Set the constructor if provided\n  if (constructor !== null) {\n    mixedProto.constructor = constructor\n  }\n\n  return mixedProto\n}\n","import { getIngredientWithProp } from './get-ingredient-with-prop.strategy'\n\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.\n *\n * The optional prototype argument allows the mixed object to sit downstream of an existing prototype chain.\n * Note that \"properties\" cannot be added, deleted, or modified.\n *\n * This strategy is less performant than the hard mix strategy, but it reflects changes to the source objects.\n *\n * @param ingredients - Ingredients to mix\n * @param prototype - Optional prototype for the mixed object\n * @returns A proxy that mixes the ingredients\n *\n * @internal\n */\nexport const proxyMix = (ingredients: any[], prototype = Object.prototype): any =>\n  new Proxy(\n    {},\n    {\n      /**\n       * Returns the prototype of the mixed object.\n       */\n      getPrototypeOf() {\n        return prototype\n      },\n\n      /**\n       * Prevents setting the prototype of the mixed object.\n       */\n      setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer')\n      },\n\n      /**\n       * Returns the property descriptor for a property from the appropriate ingredient.\n       */\n      getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop)\n      },\n\n      /**\n       * Prevents defining new properties on the mixed object.\n       */\n      defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer')\n      },\n\n      /**\n       * Checks if a property exists on any ingredient or the prototype.\n       */\n      has(_, prop) {\n        return (\n          getIngredientWithProp(prop, ingredients) !== undefined ||\n          (prototype as any)[prop] !== undefined\n        )\n      },\n\n      /**\n       * Gets a property from the appropriate ingredient or the prototype.\n       */\n      get(_, prop) {\n        const ingredient = getIngredientWithProp(prop, ingredients)\n        if (ingredient !== undefined) {\n          return ingredient[prop]\n        }\n        // Use a type assertion to tell TypeScript this access is valid\n        return (prototype as any)[prop]\n      },\n\n      /**\n       * Sets a property on the appropriate ingredient.\n       */\n      set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients)\n        if (ingredientWithProp === undefined)\n          throw new Error('Cannot set new properties on Proxies created by ts-mixer')\n\n        ingredientWithProp[prop] = val\n        return true\n      },\n\n      /**\n       * Prevents deleting properties from the mixed object.\n       */\n      deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer')\n      },\n\n      /**\n       * Returns all own property names from all ingredients.\n       */\n      ownKeys() {\n        return ingredients\n          .map(Object.getOwnPropertyNames)\n          .reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)))\n      },\n    },\n  )\n","import { proxyMix } from './proxy-mix.strategy'\n\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.\n *\n * The mixing is achieved by proxying all property access to the ingredients.\n * This is not ES5 compatible and less performant.\n * However, any changes made to the source prototypes will be reflected in the proxy-prototype,\n * which may be desirable.\n *\n * @param ingredients - Prototype ingredients to mix\n * @param constructor - Constructor function for the mixed prototype\n * @returns A proxy-prototype that mixes the ingredients\n *\n * @internal\n */\nexport const softMixProtos = (ingredients: any[], constructor: Function): object =>\n  proxyMix([...ingredients, { constructor }])\n"]}