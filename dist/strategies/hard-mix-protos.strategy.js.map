{"version":3,"sources":["../../src/utils/copy-props.util.ts","../../src/utils/proto-chain.util.ts","../../src/utils/nearest-common-proto.util.ts","../../src/strategies/hard-mix-protos.strategy.ts"],"names":["protoChain"],"mappings":";;;;;;;;;;;;;AAUO,IAAM,YAAY,CAAC,IAAA,EAAc,GAAa,EAAA,OAAA,GAAoB,EAAa,KAAA;AAEpF,EAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,yBAAA,CAA0B,GAAG,CAAA;AAGlD,EAAA,KAAA,MAAW,IAAQ,IAAA,OAAA,EAAgB,OAAA,KAAA,CAAM,IAAI,CAAA;AAG7C,EAAO,MAAA,CAAA,gBAAA,CAAiB,MAAM,KAAK,CAAA;AACrC,CAAA;;;ACPO,IAAM,aAAa,CAAC,GAAA,EAAa,YAAyB,GAAA,CAAC,GAAG,CAAgB,KAAA;AAEnF,EAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,cAAA,CAAe,GAAG,CAAA;AAGvC,EAAI,IAAA,KAAA,KAAU,MAAa,OAAA,YAAA;AAG3B,EAAA,OAAO,WAAW,KAAO,EAAA,CAAC,GAAG,YAAA,EAAc,KAAK,CAAC,CAAA;AACnD,CAAA;;;ACPO,IAAM,kBAAA,GAAqB,IAAI,IAAuC,KAAA;AAE3E,EAAI,IAAA,IAAA,CAAK,MAAW,KAAA,CAAA,EAAU,OAAA,MAAA;AAE9B,EAAA,IAAI,WAAkC,GAAA,MAAA;AAGtC,EAAA,MAAM,cAAc,IAAK,CAAA,GAAA,CAAI,CAAC,GAAQ,KAAA,UAAA,CAAW,GAAG,CAAC,CAAA;AAGrD,EAAA,OAAO,YAAY,KAAM,CAAA,CAACA,gBAAeA,WAAW,CAAA,MAAA,GAAS,CAAC,CAAG,EAAA;AAE/D,IAAA,MAAM,SAAS,WAAY,CAAA,GAAA,CAAI,CAACA,WAAeA,KAAAA,WAAAA,CAAW,KAAK,CAAA;AAC/D,IAAM,MAAA,oBAAA,GAAuB,OAAO,CAAC,CAAA;AAGrC,IAAA,IAAI,OAAO,KAAM,CAAA,CAAC,UAAU,KAAU,KAAA,oBAAoB,GAAiB,WAAA,GAAA,oBAAA;AAAA,SACtE;AAAA;AAGP,EAAO,OAAA,WAAA;AACT,CAAA;;;ACjBO,IAAM,gBAAgB,CAC3B,WAAA,EACA,WACA,EAAA,OAAA,GAAoB,EACT,KAAA;AAtBb,EAAA,IAAA,EAAA;AAwBE,EAAA,MAAM,QAAO,EAAmB,GAAA,kBAAA,CAAA,GAAG,WAAW,CAAA,KAAjC,YAAsC,MAAO,CAAA,SAAA;AAG1D,EAAM,MAAA,UAAA,GAAa,MAAO,CAAA,MAAA,CAAO,IAAI,CAAA;AAKrC,EAAM,MAAA,aAAA,GAAgB,WAAW,IAAI,CAAA;AAGrC,EAAA,KAAA,MAAW,aAAa,WAAa,EAAA;AAEnC,IAAM,MAAA,MAAA,GAAS,WAAW,SAAS,CAAA;AAKnC,IAAA,KAAA,IAAS,IAAI,MAAO,CAAA,MAAA,GAAS,CAAG,EAAA,CAAA,IAAK,GAAG,CAAK,EAAA,EAAA;AAC3C,MAAM,MAAA,QAAA,GAAW,OAAO,CAAC,CAAA;AAGzB,MAAA,IAAI,aAAc,CAAA,OAAA,CAAQ,QAAQ,CAAA,KAAM,EAAI,EAAA;AAC1C,QAAA,SAAA,CAAU,YAAY,QAAU,EAAA,CAAC,aAAe,EAAA,GAAG,OAAO,CAAC,CAAA;AAC3D,QAAA,aAAA,CAAc,KAAK,QAAQ,CAAA;AAAA;AAC7B;AACF;AAIF,EAAA,IAAI,gBAAgB,IAAM,EAAA;AACxB,IAAA,UAAA,CAAW,WAAc,GAAA,WAAA;AAAA;AAG3B,EAAO,OAAA,UAAA;AACT","file":"hard-mix-protos.strategy.js","sourcesContent":["/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.\n * Additionally gives the option to exclude properties by name.\n *\n * @param dest - The destination object\n * @param src - The source object\n * @param exclude - Optional array of property names to exclude\n *\n * @internal\n */\nexport const copyProps = (dest: object, src: object, exclude: string[] = []): void => {\n  // Get all property descriptors from the source object\n  const props = Object.getOwnPropertyDescriptors(src)\n\n  // Remove excluded properties\n  for (const prop of exclude) delete props[prop]\n\n  // Define all properties on the destination object\n  Object.defineProperties(dest, props)\n}\n","/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.\n *\n * The order of prototypes will be closest to farthest in the chain.\n * This function is used internally by various functions to traverse the prototype chain.\n *\n * @param obj - The object to get the prototype chain for\n * @param currentChain - The current chain (used for recursion)\n * @returns An array of objects representing the prototype chain\n *\n * @internal\n */\nexport const protoChain = (obj: object, currentChain: object[] = [obj]): object[] => {\n  // Get the prototype of the object\n  const proto = Object.getPrototypeOf(obj)\n\n  // If we've reached the end of the chain, return the current chain\n  if (proto === null) return currentChain\n\n  // Recursively get the rest of the chain\n  return protoChain(proto, [...currentChain, proto])\n}\n","import { protoChain } from './proto-chain.util'\n\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.\n *\n * For most unrelated objects, this function should return Object.prototype.\n * This function is used internally by the hardMixProtos function to find the common ancestor\n * of all ingredients.\n *\n * @param objs - The objects to find the common ancestor for\n * @returns The nearest common ancestor, or undefined if no objects were provided\n *\n * @internal\n */\nexport const nearestCommonProto = (...objs: object[]): object | undefined => {\n  // If no objects provided, return undefined\n  if (objs.length === 0) return undefined\n\n  let commonProto: object | undefined = undefined\n\n  // Get the prototype chain for each object\n  const protoChains = objs.map((obj) => protoChain(obj))\n\n  // Find the nearest common ancestor by working backwards from Object.prototype\n  while (protoChains.every((protoChain) => protoChain.length > 0)) {\n    // Get the last prototype in each chain (closest to Object.prototype)\n    const protos = protoChains.map((protoChain) => protoChain.pop())\n    const potentialCommonProto = protos[0]\n\n    // If all prototypes are the same, we've found a common ancestor\n    if (protos.every((proto) => proto === potentialCommonProto)) commonProto = potentialCommonProto\n    else break\n  }\n\n  return commonProto\n}\n","import { copyProps, nearestCommonProto, protoChain } from '../utils'\n\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.\n *\n * The mixing is achieved by first identifying the nearest common ancestor and using it as the prototype for a new object.\n * Then all properties/methods downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.\n * However, it's not as flexible as updates to the source prototypes aren't captured by the mixed result.\n *\n * @param ingredients - Prototype ingredients to mix\n * @param constructor - Constructor function for the mixed prototype, or null\n * @param exclude - Optional array of property names to exclude\n * @returns A new prototype object that mixes the ingredients\n *\n * @internal\n */\nexport const hardMixProtos = (\n  ingredients: any[],\n  constructor: Function | null,\n  exclude: string[] = [],\n): object => {\n  // Find the nearest common ancestor of all ingredients, or use Object.prototype if none\n  const base = nearestCommonProto(...ingredients) ?? Object.prototype\n\n  // Create a new object with the common ancestor as its prototype\n  const mixedProto = Object.create(base)\n\n  // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.\n  // We init the list with the proto chain below the nearest common ancestor because we don't want any of those\n  // methods mixed in when they will already be accessible via prototype access.\n  const visitedProtos = protoChain(base)\n\n  // Process each ingredient\n  for (const prototype of ingredients) {\n    // Get the prototype chain for this ingredient\n    const protos = protoChain(prototype)\n\n    // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n    // This ensures that properties closer to the actual class take precedence over properties\n    // from further up the prototype chain.\n    for (let i = protos.length - 1; i >= 0; i--) {\n      const newProto = protos[i]\n\n      // Only copy properties from prototypes we haven't visited yet\n      if (visitedProtos.indexOf(newProto) === -1) {\n        copyProps(mixedProto, newProto, ['constructor', ...exclude])\n        visitedProtos.push(newProto)\n      }\n    }\n  }\n\n  // Set the constructor if provided\n  if (constructor !== null) {\n    mixedProto.constructor = constructor\n  }\n\n  return mixedProto\n}\n"]}