{"version":3,"sources":["../../src/utils/proto-chain.util.ts","../../src/strategies/get-ingredient-with-prop.strategy.ts"],"names":[],"mappings":";;;;;;;;;;;AAYO,IAAM,aAAa,CAAC,GAAA,EAAa,YAAyB,GAAA,CAAC,GAAG,CAAgB,KAAA;AAEnF,EAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,cAAA,CAAe,GAAG,CAAA;AAGvC,EAAI,IAAA,KAAA,KAAU,MAAa,OAAA,YAAA;AAG3B,EAAA,OAAO,WAAW,KAAO,EAAA,CAAC,GAAG,YAAA,EAAc,KAAK,CAAC,CAAA;AACnD,CAAA;;;ACNa,IAAA,qBAAA,GAAwB,CAAC,IAAA,EAAgC,WAA4B,KAAA;AAEhG,EAAA,MAAM,cAAc,WAAY,CAAA,GAAA,CAAI,CAAC,UAAe,KAAA,UAAA,CAAW,UAAU,CAAC,CAAA;AAG1E,EAAA,IAAI,UAAa,GAAA,CAAA;AAIjB,EAAA,IAAI,qBAAwB,GAAA,IAAA;AAE5B,EAAA,OAAO,qBAAuB,EAAA;AAE5B,IAAwB,qBAAA,GAAA,KAAA;AAGxB,IAAA,KAAA,IAAS,IAAI,WAAY,CAAA,MAAA,GAAS,CAAG,EAAA,CAAA,IAAK,GAAG,CAAK,EAAA,EAAA;AAChD,MAAA,MAAM,YAAe,GAAA,WAAA,CAAY,CAAC,CAAA,CAAE,UAAU,CAAA;AAC9C,MAAI,IAAA,YAAA,KAAiB,MAAa,IAAA,YAAA,KAAiB,IAAM,EAAA;AAEvD,QAAwB,qBAAA,GAAA,IAAA;AAGxB,QAAA,IAAI,MAAO,CAAA,wBAAA,CAAyB,YAAc,EAAA,IAAI,KAAK,MAAW,EAAA;AACpE,UAAO,OAAA,WAAA,CAAY,CAAC,CAAA,CAAE,CAAC,CAAA;AAAA;AACzB;AACF;AAIF,IAAA,UAAA,EAAA;AAAA;AAIF,EAAO,OAAA,MAAA;AACT","file":"get-ingredient-with-prop.strategy.mjs","sourcesContent":["/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.\n *\n * The order of prototypes will be closest to farthest in the chain.\n * This function is used internally by various functions to traverse the prototype chain.\n *\n * @param obj - The object to get the prototype chain for\n * @param currentChain - The current chain (used for recursion)\n * @returns An array of objects representing the prototype chain\n *\n * @internal\n */\nexport const protoChain = (obj: object, currentChain: object[] = [obj]): object[] => {\n  // Get the prototype of the object\n  const proto = Object.getPrototypeOf(obj)\n\n  // If we've reached the end of the chain, return the current chain\n  if (proto === null) return currentChain\n\n  // Recursively get the rest of the chain\n  return protoChain(proto, [...currentChain, proto])\n}\n","import { protoChain } from '../utils/proto-chain.util'\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n *\n * This function is used by the proxy mixing strategy to find the ingredient that has a specific property.\n * It searches through the prototype chains of all ingredients in a breadth-first manner.\n *\n * @param prop - Property to search for\n * @param ingredients - Ingredients to search in\n * @returns The ingredient with the property, or undefined if not found\n *\n * @internal\n */\nexport const getIngredientWithProp = (prop: string | number | symbol, ingredients: any[]): any => {\n  // Get the prototype chain for each ingredient\n  const protoChains = ingredients.map((ingredient) => protoChain(ingredient))\n\n  // Since we search breadth-first, we need to keep track of our depth in the prototype chains\n  let protoDepth = 0\n\n  // Not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n  // prototype chains has an object at this depth\n  let protosAreLeftToSearch = true\n\n  while (protosAreLeftToSearch) {\n    // With the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n    protosAreLeftToSearch = false\n\n    // Scan through the ingredients right to left (to prioritize later ingredients)\n    for (let i = ingredients.length - 1; i >= 0; i--) {\n      const searchTarget = protoChains[i][protoDepth]\n      if (searchTarget !== undefined && searchTarget !== null) {\n        // If we find something, this is proof that this horizontal slice potentially has more objects to search\n        protosAreLeftToSearch = true\n\n        // Eureka, we found it\n        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n          return protoChains[i][0]\n        }\n      }\n    }\n\n    // Move to the next level in the prototype chain\n    protoDepth++\n  }\n\n  // Property not found in any ingredient\n  return undefined\n}\n"]}